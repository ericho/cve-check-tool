extern crate curl;
extern crate libc;

use libc::c_char;
use std::ffi::{CStr, CString};
use std::path::Path;
use std::fs;
use std::io::Write;
use std::fs::File;
use std::mem::transmute;

use curl::easy::{Easy, TimeCondition};

#[repr(C)]
pub struct cve_string {
    str: *const c_char,
    len: usize,
}

// This method will be deleted in the future. The program uses
// some utilities, like this, to manage string. However in a full
// rust implementation this won't make sense.
#[no_mangle]
pub extern "C" fn cve_string_cat(s: *mut cve_string, append: *const c_char) -> bool {
    if s.is_null() || append.is_null() {
        return false;
    }

    unsafe {
        if (*s).str.is_null() {
            return false;
        }

        let mut dest: String = String::from("");

        let _str = CStr::from_ptr((*s).str).to_string_lossy();
        dest.push_str(&_str);

        let _append = CStr::from_ptr(append).to_string_lossy();
        dest.push_str(&_append);

        if _append.len() < (*s).len {
            return false;
        }

        libc::free((*s).str as *mut libc::c_void);
        dest.shrink_to_fit();
        (*s).len = dest.len();
        let _tmp_str = CString::new(dest).unwrap();
        (*s).str = _tmp_str.as_ptr();
        std::mem::forget(_tmp_str);
    }
    true
}

#[no_mangle]
pub extern "C" fn cve_string_dup(mystr: *const c_char) -> *const cve_string {
    if mystr.is_null() {
        return std::ptr::null();
    }
    let mut st = Box::new(new_cve_string());
    let mut dest: String = String::from("");

    unsafe {
        let _str = CStr::from_ptr(mystr).to_string_lossy();
        dest.push_str(&_str);
        st.len = dest.len();
        let _tmp_str = CString::new(dest).unwrap();
        st.str = _tmp_str.as_ptr();
        std::mem::forget(_tmp_str);
        transmute(st)
    }
}

fn new_cve_string() -> cve_string {
    cve_string {
        str: std::ptr::null(),
        len: 0,
    }
}

#[repr(C)]
pub enum FetchStatus {
    FetchStatusFail = 0,
    FetchStatusUpdate = 1,
    FetchStatusOk = 2,
}

fn c_to_string(c_str: *const c_char) -> Option<String> {
    unsafe {
        if c_str.is_null() {
            return None;
        }
        Some(CStr::from_ptr(c_str).to_string_lossy().to_string())
    }
}

// If the file exists, check for the modified time and set
// curl to check this time value. If the TimeCondition is met
// the file will be downloaded.
fn curl_set_time_val(curl: &mut Easy, target: &str) -> FetchStatus {
    let mut rc = FetchStatus::FetchStatusOk;
    let target_path = Path::new(&target);
    if target_path.exists() {
        if curl.time_condition(TimeCondition::IfModifiedSince).is_err() {
            return FetchStatus::FetchStatusFail;
        }

        let metadata = fs::metadata(target_path).unwrap();
        let modified = metadata.modified().unwrap().elapsed().unwrap();

        if curl.time_value(modified.as_secs() as i64).is_err() {
            return FetchStatus::FetchStatusFail;
        }
    } else {
        rc = FetchStatus::FetchStatusUpdate;
    }
    rc
}

#[no_mangle]
pub extern "C" fn fetch_uri(
    uri: *const c_char,
    target: *const c_char,
    verbose: bool,
    cacert_file: *const c_char,
) -> FetchStatus {
    let r_uri = c_to_string(uri).unwrap();
    let target = c_to_string(target).unwrap();
    let cert_file = c_to_string(cacert_file);
    let mut rc: FetchStatus;

    let mut curl = Easy::new();

    if let Some(cert) = cert_file {
        let cert_path = Path::new(&cert);
        if curl.cainfo(cert_path).is_err() {
            return FetchStatus::FetchStatusFail;
        }
    }

    let res = curl_set_time_val(&mut curl, &target);
    match res {
        FetchStatus::FetchStatusFail => return res,
        _ => rc = res,
    }

    if curl.url(&r_uri).is_err() {
        return FetchStatus::FetchStatusFail;
    }

    if verbose == true {
        curl.progress(true).unwrap();
    }

    let mut file = File::create(&target).unwrap();
    curl.write_function(move |data| Ok(file.write(data).unwrap()))
        .unwrap();

    if curl.follow_location(true).is_err() {
        return FetchStatus::FetchStatusFail;
    }

    if curl.perform().is_err() {
        return FetchStatus::FetchStatusFail;
    }

    if curl.time_condition_unmet().unwrap() {
        rc = FetchStatus::FetchStatusOk;
    }
    rc
}

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
